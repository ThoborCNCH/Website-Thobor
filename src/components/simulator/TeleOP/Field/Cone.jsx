/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useRef, useEffect } from 'react'
import { useGLTF } from '@react-three/drei'
import { useBox, useCylinder } from '@react-three/cannon';
import { Quaternion, Vector3 } from 'three';
import DoamneIartaCeUrmeaza from '../Robot/DoamneIartaCeUrmeaza';
import { useState } from 'react';
import { useFrame } from 'react-three-fiber';

export default function Cone({ position,  props }) {

  const { nodes, materials } = useGLTF('/cone.glb');

  materials.da = 1;

  // useBox(
  //   () => ({
  //     args: [0.23, .5, 0.23],
  //     mass: .8,
  //     position: position
  //   }),
  //   useRef(null)
  // );

  const [coneBodyCylinder, coneAPICylinder] = useCylinder(
    () => ({
      // args: [.71, 1.4, 3.4, 32, 1, true],
      args: [1, 1, 3.4, 32, 1, true],
      mass: 1,
      position: position,
      type: 'Dynamic'
    }),
    useRef(null)
  );

  useFrame((state) => {
    let bratPosition = new Vector3(0, 0, 0);
    bratPosition.setFromMatrixPosition(DoamneIartaCeUrmeaza.bratBody.current.matrixWorld)
    // console.log("dada", bratPosition)

    let bratQuaternion = new Quaternion(0, 0, 0, 0);
    bratQuaternion.setFromRotationMatrix(DoamneIartaCeUrmeaza.bratBody.current.matrixWorld);

    let conePosition = new Vector3(0, 0, 0)
    conePosition.setFromMatrixPosition(coneBodyCylinder.current.matrixWorld);

    let dist = conePosition.distanceTo(bratPosition)

    if(dist <= 2 && conePosition.y >= 1.5 && !DoamneIartaCeUrmeaza.controls.f)
    {
      // coneAPICylinder.position.copy(bratPosition)
      // coneAPICylinder.quaternion.copy()

      // coneBodyCylinder.current.type = 'Static'

      let carrierPosition = new Vector3(0, 0, 0);
      carrierPosition.applyQuaternion(bratQuaternion);

      let finalCarryPosition = carrierPosition.clone().add(bratPosition);
      // coneAPICylinder.position.copy(finalCarryPosition);
      // coneAPICylinder.quaternion.copy(bratQuaternion);
      coneAPICylinder.position.copy(bratPosition.add(new Vector3(0.5)))
      coneAPICylinder.velocity.set(0, 0, 0);
      coneAPICylinder.angularVelocity.set(0, 0, 0);
      coneAPICylinder.quaternion.copy(new Quaternion(0, 0, 0, 1))
    } 
  })

  useEffect(() => {

    const keyDown = (e) => {
      if (e.key === "r") {
        coneAPICylinder.position.set(position[0], position[1], position[2]);
        coneAPICylinder.velocity.set(0, 0, 0);
        coneAPICylinder.angularVelocity.set(0, 0, 0);
        coneAPICylinder.rotation.set(0, 0, 0);
      }
    }

    window.addEventListener("keydown", keyDown);
    return () => {
      window.removeEventListener("keydown", keyDown);
    };

  }, [coneAPICylinder.angularVelocity, coneAPICylinder.rotation, coneAPICylinder.velocity, coneAPICylinder.position, position]);


  useEffect(() => {
    setTimeout(() => {
      coneAPICylinder.position.set(position[0], position[1], position[2]);
      coneAPICylinder.velocity.set(0, 0, 0);
      coneAPICylinder.angularVelocity.set(0, 0, 0);
      coneAPICylinder.rotation.set(0, 0, 0);
    }, 100);
  }, [coneAPICylinder.angularVelocity, coneAPICylinder.rotation, coneAPICylinder.velocity, coneAPICylinder.position, position]);


  return (
    <group ref={coneBodyCylinder}>
      {/* <mesh>
        <boxGeometry args={[1,1,1]}/>
        <meshStandardMaterial attach={"material"} />
      </mesh> */}
      {/* <mesh position={[0, (3.4 / 2) - 1.5, 0]}>
        <cylinderGeometry args={[.71, 1.4, 3.4, 32, 1, true]} attach="geometry" />
        <meshStandardMaterial attach={"material"} color={0x000000} />
      </mesh> */}
      <group {...props} dispose={null} scale={[0.028, 0.028, 0.028]} position={[0, -1.55, 0]}>
        <mesh geometry={nodes.mesh_0.geometry} material={nodes.mesh_0.material} >
          <meshStandardMaterial attach={"material"} color={0x373cdb} />
        </mesh>
      </group>
    </group>
  )
}

useGLTF.preload('/cone.glb')
